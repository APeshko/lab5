# Лабораторная работа №5: Многопоточность в C++

## Цель работы
- Освоить создание и управление потоками с помощью `std::thread`
- Изучить механизмы синхронизации: мьютексы и атомарные операции
- Реализовать параллельный алгоритм обработки изображений

## Реализация

### 1. Последовательное размытие
Реализована функция `sequentialBlur`, которая применяет размытие по среднему с ядром 3x3 или 5x5 ко всему изображению последовательно.

### 2. Параллельное размытие с std::thread
Изображение разделяется на горизонтальные полосы, каждая из которых обрабатывается отдельным потоком. Мьютексы не требуются, так как каждый поток работает со своей областью выходного изображения.

### 3. Параллельное размытие с OpenMP
Реализована версия с использованием директив OpenMP (`#pragma omp parallel for`), которая автоматически распределяет работу по потокам.

### 4. Атомарные операции
Реализованы две версии инкремента счетчика:
- С использованием мьютекса (`std::mutex`)
- С использованием атомарной переменной (`std::atomic<int>`)

## Результаты тестирования

### Производительность размытия (ядро 5x5, изображение 4000x3000)

| Метод               | Время (мс)| Ускорение |
|---------------------|-----------|-----------|
| Последовательный    | 12500     | 1x        |
| Параллельный (4 потока) | 3800  | 3.3x      |
| OpenMP (4 потока)   | 3600      | 3.5x      |

### Атомарные операции (1,000,000 итераций, 4 потока)

| Метод      |Время (мс) |
|------------|-----------|
| Мьютекс    | 45        |
| Atomic     | 12        |

## Выводы
1. Многопоточность позволяет значительно ускорить обработку изображений (в 3-4 раза на 4-ядерном процессоре)
2. OpenMP предоставляет более простой способ параллелизации по сравнению с ручным управлением потоками
3. Атомарные операции значительно эффективнее мьютексов для простых операций
4. Для достижения максимальной производительности важно минимизировать синхронизацию между потоками
